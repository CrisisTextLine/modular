package goldenmodule

import (
	"context"
	"reflect"
	"time"

	"github.com/CrisisTextLine/modular"
)

// MockApplication implements the modular.Application interface for testing
type MockApplication struct {
	configSections map[string]modular.ConfigProvider
	services       map[string]interface{}
	logger         modular.Logger
	verboseConfig  bool
}

// NewMockApplication creates a new mock application for testing
func NewMockApplication() *MockApplication {
	return &MockApplication{
		configSections: make(map[string]modular.ConfigProvider),
		services:       make(map[string]interface{}),
	}
}

// ConfigProvider returns a nil ConfigProvider in the mock
func (m *MockApplication) ConfigProvider() modular.ConfigProvider {
	return nil
}

// SvcRegistry returns the service registry
func (m *MockApplication) SvcRegistry() modular.ServiceRegistry {
	return m.services
}

// RegisterModule mocks module registration
func (m *MockApplication) RegisterModule(module modular.Module) {
	// No-op in mock
}

// RegisterConfigSection registers a config section with the mock app
func (m *MockApplication) RegisterConfigSection(section string, cp modular.ConfigProvider) {
	m.configSections[section] = cp
}

// ConfigSections returns all registered configuration sections
func (m *MockApplication) ConfigSections() map[string]modular.ConfigProvider {
	return m.configSections
}

// GetConfigSection retrieves a configuration section from the mock
func (m *MockApplication) GetConfigSection(section string) (modular.ConfigProvider, error) {
	cp, exists := m.configSections[section]
	if !exists {
		return nil, modular.ErrConfigSectionNotFound
	}
	return cp, nil
}

// RegisterService adds a service to the mock registry
func (m *MockApplication) RegisterService(name string, service interface{}) error {
	if _, exists := m.services[name]; exists {
		return modular.ErrServiceAlreadyRegistered
	}
	m.services[name] = service
	return nil
}

// GetService retrieves a service from the mock registry
func (m *MockApplication) GetService(name string, target interface{}) error {
	// Simple implementation that doesn't handle type conversion
	service, exists := m.services[name]
	if !exists {
		return modular.ErrServiceNotFound
	}

	// Just return the service without type checking for the mock
	// In a real implementation, this would properly handle the type conversion
	val, ok := target.(*interface{})
	if ok {
		*val = service
	}

	return nil
}

// Init mocks application initialization
func (m *MockApplication) Init() error {
	return nil
}

// Start mocks application start
func (m *MockApplication) Start() error {
	return nil
}

// Stop mocks application stop
func (m *MockApplication) Stop() error {
	return nil
}

// Run mocks application run
func (m *MockApplication) Run() error {
	return nil
}

// Logger returns the logger for the mock
func (m *MockApplication) Logger() modular.Logger {
	return m.logger
}

// SetLogger sets the logger for the mock application
func (m *MockApplication) SetLogger(logger modular.Logger) {
	m.logger = logger
}

// SetVerboseConfig sets verbose configuration debugging for the mock
func (m *MockApplication) SetVerboseConfig(enabled bool) {
	m.verboseConfig = enabled
}

// IsVerboseConfig returns whether verbose configuration debugging is enabled
func (m *MockApplication) IsVerboseConfig() bool {
	return m.verboseConfig
}

// Context returns a background context for the mock application
func (m *MockApplication) Context() context.Context { return context.Background() }

// GetServicesByModule returns all services provided by a specific module (mock implementation)
func (m *MockApplication) GetServicesByModule(moduleName string) []string { return []string{} }

// GetServiceEntry retrieves detailed information about a registered service (mock implementation)
func (m *MockApplication) GetServiceEntry(serviceName string) (*modular.ServiceRegistryEntry, bool) {
	return nil, false
}

// GetServicesByInterface returns all services that implement the given interface (mock implementation)
func (m *MockApplication) GetServicesByInterface(interfaceType reflect.Type) []*modular.ServiceRegistryEntry {
	return []*modular.ServiceRegistryEntry{}
}

// GetModule returns a module by name (mock implementation)
func (m *MockApplication) GetModule(name string) modular.Module {
	return nil
}

// GetAllModules returns all registered modules (mock implementation)
func (m *MockApplication) GetAllModules() map[string]modular.Module {
	return make(map[string]modular.Module)
}

// StartTime returns the application start time (mock implementation)
func (m *MockApplication) StartTime() time.Time {
	return time.Time{}
}

// OnConfigLoaded registers a config loaded hook (mock implementation)
func (m *MockApplication) OnConfigLoaded(hook func(app modular.Application) error) {}

// NewStdConfigProvider is a simple mock implementation of modular.ConfigProvider
func NewStdConfigProvider(config interface{}) modular.ConfigProvider {
	return &mockConfigProvider{config: config}
}

type mockConfigProvider struct {
	config interface{}
}

func (m *mockConfigProvider) GetConfig() interface{} {
	return m.config
}
