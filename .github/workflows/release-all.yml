name: Release All Components
run-name: Orchestrated release (type=${{ github.event.inputs.releaseType }})

on:
  workflow_dispatch:
    inputs:
      releaseType:
        description: 'Release type for all changed components (patch|minor|major)'
        required: true
        type: choice
        options: [patch, minor, major]
        default: patch

permissions:
  contents: write
  actions: write

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      core_changed: ${{ steps.core.outputs.core_changed }}
      modules_with_changes: ${{ steps.modules.outputs.modules_with_changes }}
      modules_without_changes: ${{ steps.modules.outputs.modules_without_changes }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Detect core changes
        id: core
        shell: bash
        run: |
          set -euo pipefail
          LATEST_TAG=$(git tag -l 'v*' | grep -v '/' | sort -V | tail -n1 || echo '')
          echo "Latest core tag: $LATEST_TAG"
          HAS_CHANGES=false
          if [ -z "$LATEST_TAG" ]; then
            FILE=$(find . -maxdepth 1 -type f \( -name '*.go' -o -name 'go.mod' -o -name 'go.sum' \) | head -1 || true)
            if [ -n "$FILE" ]; then HAS_CHANGES=true; fi
          else
            CHANGED=$(git diff --name-only ${LATEST_TAG}..HEAD | grep -v '^modules/' || true)
            RELEVANT=""
            if [ -n "$CHANGED" ]; then
              while IFS= read -r f; do
                [[ $f == *_test.go ]] && continue
                [[ $f == *.md ]] && continue
                [[ $f == .github/* ]] && continue
                [[ $f == examples/* ]] && continue
                if [[ $f == *.go ]] || [[ $f == go.mod ]] || [[ $f == go.sum ]]; then RELEVANT+="$f "; fi
              done <<< "$CHANGED"
            fi
            if [ -n "$RELEVANT" ]; then HAS_CHANGES=true; fi
          fi
          echo "core_changed=$HAS_CHANGES" >> $GITHUB_OUTPUT
          echo "Core changed? $HAS_CHANGES"

      - name: Detect module changes
        id: modules
        shell: bash
        run: |
          set -euo pipefail
          MODULE_DIRS=$(find modules -maxdepth 1 -mindepth 1 -type d -exec basename {} \; 2>/dev/null || true)
          WITH_CHANGES=()
          WITHOUT_CHANGES=()
          for M in $MODULE_DIRS; do
            LATEST_TAG=$(git tag -l "modules/${M}/v*" | sort -V | tail -n1 || echo '')
            HAS=false
            if [ -z "$LATEST_TAG" ]; then
              FILE=$(find "modules/${M}" -type f \( -name '*.go' -o -name 'go.mod' -o -name 'go.sum' \) | head -1 || true)
              [ -n "$FILE" ] && HAS=true || HAS=false
            else
              CHANGED=$(git diff --name-only ${LATEST_TAG}..HEAD -- "modules/${M}" || true)
              RELEVANT=""
              if [ -n "$CHANGED" ]; then
                while IFS= read -r f; do
                  [[ $f == *_test.go ]] && continue
                  [[ $f == *.md ]] && continue
                  if [[ $f == *.go ]] || [[ $f == go.mod ]] || [[ $f == go.sum ]]; then RELEVANT+="$f "; fi
                done <<< "$CHANGED"
              fi
              [ -n "$RELEVANT" ] && HAS=true || HAS=false
            fi
            if [ "$HAS" = true ]; then
              WITH_CHANGES+=("$M")
            else
              WITHOUT_CHANGES+=("$M")
            fi
          done
          build_json_array() {
            local arr=("$@")
            if [ ${#arr[@]} -eq 0 ] || { [ ${#arr[@]} -eq 1 ] && [ -z "${arr[0]}" ]; }; then
              printf '[]'
              return 0
            fi
            if command -v jq >/dev/null 2>&1; then
              printf '%s\n' "${arr[@]}" | jq -R . | jq -s . -c
            else
              local first=1
              printf '['
              for e in "${arr[@]}"; do
                [ -z "$e" ] && continue
                if [ $first -eq 0 ]; then printf ','; fi
                printf '"%s"' "$e"
                first=0
              done
              printf ']'
            fi
          }
          WITH_JSON=$(build_json_array "${WITH_CHANGES[@]}")
          WITHOUT_JSON=$(build_json_array "${WITHOUT_CHANGES[@]}")
          # Only write valid key=value lines to GITHUB_OUTPUT
          echo "modules_with_changes=${WITH_JSON}" >> "$GITHUB_OUTPUT"
          echo "modules_without_changes=${WITHOUT_JSON}" >> "$GITHUB_OUTPUT"
          echo "Modules with changes: ${WITH_JSON}"
          echo "Modules without changes: ${WITHOUT_JSON}"

  release-core:
    needs: detect
    if: needs.detect.outputs.core_changed == 'true'
    uses: ./.github/workflows/release.yml
    with:
      releaseType: ${{ github.event.inputs.releaseType }}
    secrets: inherit

  release-modules:
    needs: detect
    if: needs.detect.outputs.modules_with_changes != '[]'
    strategy:
      matrix:
        module: ${{ fromJson(needs.detect.outputs.modules_with_changes) }}
    uses: ./.github/workflows/module-release.yml
    with:
      module: ${{ matrix.module }}
      releaseType: ${{ github.event.inputs.releaseType }}
    secrets: inherit

  ensure-core:
    needs: detect
    if: needs.detect.outputs.core_changed != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '^1.25'
          check-latest: true
      - name: Build modcli
        run: |
          cd cmd/modcli && go build -o modcli
      - name: Recreate missing release (if needed) with contract diff
        id: ensure
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          CURR=$(git tag -l 'v*' | grep -v '/' | sort -V | tail -n1 || true)
          [ -z "$CURR" ] && { echo 'No core tag exists yet; nothing to ensure.'; exit 0; }
          if gh release view "$CURR" >/dev/null 2>&1; then
            echo "Release already exists for $CURR (no recreation needed)."
            echo "release_url=$(gh release view "$CURR" --json url --jq .url)" >> $GITHUB_OUTPUT
            exit 0
          fi
          PREV=$(git tag -l 'v*' | grep -v '/' | sort -V | tail -n2 | head -n1 || echo '')
          mkdir -p artifacts/diffs
          extract () { REF=$1; OUT=$2; [ -z "$REF" ] && return 0; TMP=$(mktemp -d); git archive "$REF" | tar -x -C "$TMP"; mkdir -p "$TMP/cmd/modcli"; cp cmd/modcli/modcli "$TMP/cmd/modcli/" || true; (cd "$TMP" && ./cmd/modcli/modcli contract extract . -o contract.json) || true; [ -f "$TMP/contract.json" ] && mv "$TMP/contract.json" "$OUT" || true; }
          extract "$PREV" prev.json
          extract "$CURR" curr.json
          CHANGE_NOTE="No API contract differences compared to previous release."
          if [ -f prev.json ] && [ -f curr.json ]; then
            if ./cmd/modcli/modcli contract compare prev.json curr.json -o artifacts/diffs/core.json --format=markdown > artifacts/diffs/core.md 2>/dev/null; then
              if [ -s artifacts/diffs/core.md ]; then CHANGE_NOTE="See diff below."; fi
            else
              echo '(Breaking changes or compare failure; diff may be incomplete)' > artifacts/diffs/core.md
              CHANGE_NOTE='Potential breaking changes detected.'
            fi
          fi
          {
            echo "# Release $CURR"; echo; echo "Ensured release object (no new code changes)."; echo; echo "## API Contract Changes"; echo; echo "$CHANGE_NOTE"; echo;
            if [ -f artifacts/diffs/core.md ] && [ -s artifacts/diffs/core.md ]; then
              cat artifacts/diffs/core.md; echo
              if [ -f artifacts/diffs/core.json ] && [ -s artifacts/diffs/core.json ]; then
                echo '### Raw Contract JSON Diff'; echo '```json'; (jq . artifacts/diffs/core.json 2>/dev/null || cat artifacts/diffs/core.json); echo '```'
              fi
            fi
          } > changelog.md
          gh release create "$CURR" --title "Modular $CURR" --notes-file changelog.md --repo ${{ github.repository }} --latest
          URL=$(gh release view "$CURR" --json url --jq .url)
          echo "release_url=$URL" >> $GITHUB_OUTPUT
      - name: Re-announce to Go proxy
        if: steps.ensure.outputs.release_url
        run: |
          CURR=$(git tag -l 'v*' | grep -v '/' | sort -V | tail -n1 || true)
          [ -z "$CURR" ] && exit 0
          GOPROXY=proxy.golang.org go list -m github.com/CrisisTextLine/modular@${CURR}

  ensure-modules:
    needs: detect
    if: needs.detect.outputs.modules_without_changes != '[]'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '^1.25'
          check-latest: true
      - name: Build modcli
        run: |
          cd cmd/modcli && go build -o modcli
      - name: Ensure module releases (create if missing) with contract diffs
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          MODULES='${{ needs.detect.outputs.modules_without_changes }}'
          echo "$MODULES" | jq -r '.[]' | while read M; do
            [ -z "$M" ] && continue
            TAG=$(git tag -l "modules/${M}/v*" | sort -V | tail -n1 || true)
            [ -z "$TAG" ] && { echo "Module $M has no tags yet; skipping."; continue; }
            if gh release view "$TAG" >/dev/null 2>&1; then
              echo "Release exists for $TAG"; continue
            fi
            PREV=$(git tag -l "modules/${M}/v*" | sort -V | tail -n2 | head -n1 || echo '')
            extract_module () { REF=$1; OUT=$2; [ -z "$REF" ] && return 0; TMP=$(mktemp -d); git archive "$REF" | tar -x -C "$TMP"; mkdir -p "$TMP/cmd/modcli"; cp cmd/modcli/modcli "$TMP/cmd/modcli/" || true; (cd "$TMP/modules/${M}" && ./cmd/modcli/modcli contract extract . -o contract.json) || true; [ -f "$TMP/modules/${M}/contract.json" ] && mv "$TMP/modules/${M}/contract.json" "$OUT" || true; }
            extract_module "$PREV" prev.json
            extract_module "$TAG" curr.json
            CHANGE_NOTE="No API contract differences compared to previous release."
            if [ -f prev.json ] && [ -f curr.json ]; then
              if ./cmd/modcli/modcli contract compare prev.json curr.json -o diff.json --format=markdown > diff.md 2>/dev/null; then
                [ -s diff.md ] && CHANGE_NOTE="See diff below."
              else
                echo '(Breaking changes or compare failure; diff may be incomplete)' > diff.md
                CHANGE_NOTE='Potential breaking changes detected.'
              fi
            fi
            {
              echo "# ${M} ${TAG##*/}"; echo; echo "Ensured release object (no new code changes)."; echo; echo "## API Contract Changes"; echo; echo "$CHANGE_NOTE"; echo;
              if [ -f diff.md ] && [ -s diff.md ]; then
                cat diff.md; echo
                if [ -f diff.json ] && [ -s diff.json ]; then
                  echo '### Raw Contract JSON Diff'; echo '```json'; (jq . diff.json 2>/dev/null || cat diff.json); echo '```'
                fi
              fi
            } > changelog.md
            gh release create "$TAG" --title "${M} ${TAG##*/}" --notes-file changelog.md --repo ${{ github.repository }} --latest=false
            MOD_PATH="github.com/CrisisTextLine/modular/modules/${M}"; VER=${TAG##*/}
            GOPROXY=proxy.golang.org go list -m ${MOD_PATH}@${VER}
          done

  summary:
    runs-on: ubuntu-latest
    needs:
      - detect
      - release-core
      - release-modules
      - ensure-core
      - ensure-modules
    if: always()
    steps:
      - name: Release summary
        shell: bash
        run: |
          set -euo pipefail
          echo '========================================='
          echo 'Release Summary'
          echo '-----------------------------------------'
          if [ "${{ needs.detect.outputs.core_changed }}" = "true" ]; then
            echo "Core: attempted release -> ${{ needs.release-core.result }}"
          else
            echo "Core: no changes; ensure job result -> ${{ needs.ensure-core.result }}"
          fi
          MWCH='${{ needs.detect.outputs.modules_with_changes }}'
          MWOUT='${{ needs.detect.outputs.modules_without_changes }}'
          if [ "$MWCH" != "[]" ]; then
            echo "Modules with changes: $(echo "$MWCH" | jq -r '.[]' | tr '\n' ' ') (job result: ${{ needs.release-modules.result }})"
          fi
          if [ "$MWOUT" != "[]" ]; then
            echo "Modules without changes (ensured if missing release): $(echo "$MWOUT" | jq -r '.[]' | tr '\n' ' ') (job result: ${{ needs.ensure-modules.result }})"
          fi
          echo '========================================='
