package jsonschema

import (
	"fmt"
	"time"

	"github.com/CrisisTextLine/modular"
)

// CloudEvents emission and handling step methods

func (ctx *JSONSchemaBDDTestContext) aSchemaCompiledEventShouldBeEmitted() error {
	time.Sleep(100 * time.Millisecond) // Give time for async event emission

	events := ctx.eventObserver.GetEvents()
	for _, event := range events {
		if event.Type() == EventTypeSchemaCompiled {
			return nil
		}
	}

	eventTypes := make([]string, len(events))
	for i, event := range events {
		eventTypes[i] = event.Type()
	}

	return fmt.Errorf("schema compiled event not found. Captured events: %v", eventTypes)
}

func (ctx *JSONSchemaBDDTestContext) theEventShouldContainTheSourceInformation() error {
	time.Sleep(100 * time.Millisecond) // Give time for async event emission

	events := ctx.eventObserver.GetEvents()
	for _, event := range events {
		if event.Type() == EventTypeSchemaCompiled {
			var eventData map[string]interface{}
			if err := event.DataAs(&eventData); err != nil {
				continue
			}
			if source, ok := eventData["source"]; ok && source != "" {
				return nil
			}
		}
	}

	return fmt.Errorf("schema compiled event with source information not found")
}

func (ctx *JSONSchemaBDDTestContext) aSchemaErrorEventShouldBeEmitted() error {
	time.Sleep(100 * time.Millisecond) // Give time for async event emission

	events := ctx.eventObserver.GetEvents()
	for _, event := range events {
		if event.Type() == EventTypeSchemaError {
			return nil
		}
	}

	eventTypes := make([]string, len(events))
	for i, event := range events {
		eventTypes[i] = event.Type()
	}

	return fmt.Errorf("schema error event not found. Captured events: %v", eventTypes)
}

func (ctx *JSONSchemaBDDTestContext) aValidateBytesEventShouldBeEmitted() error {
	time.Sleep(100 * time.Millisecond) // Give time for async event emission

	events := ctx.eventObserver.GetEvents()
	for _, event := range events {
		if event.Type() == EventTypeValidateBytes {
			return nil
		}
	}

	eventTypes := make([]string, len(events))
	for i, event := range events {
		eventTypes[i] = event.Type()
	}

	return fmt.Errorf("validate bytes event not found. Captured events: %v", eventTypes)
}

func (ctx *JSONSchemaBDDTestContext) aValidationSuccessEventShouldBeEmitted() error {
	time.Sleep(100 * time.Millisecond) // Give time for async event emission

	events := ctx.eventObserver.GetEvents()
	for _, event := range events {
		if event.Type() == EventTypeValidationSuccess {
			return nil
		}
	}

	eventTypes := make([]string, len(events))
	for i, event := range events {
		eventTypes[i] = event.Type()
	}

	return fmt.Errorf("validation success event not found. Captured events: %v", eventTypes)
}

func (ctx *JSONSchemaBDDTestContext) aValidationFailedEventShouldBeEmitted() error {
	time.Sleep(100 * time.Millisecond) // Give time for async event emission

	events := ctx.eventObserver.GetEvents()
	for _, event := range events {
		if event.Type() == EventTypeValidationFailed {
			return nil
		}
	}

	eventTypes := make([]string, len(events))
	for i, event := range events {
		eventTypes[i] = event.Type()
	}

	return fmt.Errorf("validation failed event not found. Captured events: %v", eventTypes)
}

func (ctx *JSONSchemaBDDTestContext) aValidateReaderEventShouldBeEmitted() error {
	time.Sleep(100 * time.Millisecond) // Give time for async event emission

	events := ctx.eventObserver.GetEvents()
	for _, event := range events {
		if event.Type() == EventTypeValidateReader {
			return nil
		}
	}

	eventTypes := make([]string, len(events))
	for i, event := range events {
		eventTypes[i] = event.Type()
	}

	return fmt.Errorf("validate reader event not found. Captured events: %v", eventTypes)
}

func (ctx *JSONSchemaBDDTestContext) aValidateInterfaceEventShouldBeEmitted() error {
	time.Sleep(100 * time.Millisecond) // Give time for async event emission

	events := ctx.eventObserver.GetEvents()
	for _, event := range events {
		if event.Type() == EventTypeValidateInterface {
			return nil
		}
	}

	eventTypes := make([]string, len(events))
	for i, event := range events {
		eventTypes[i] = event.Type()
	}

	return fmt.Errorf("validate interface event not found. Captured events: %v", eventTypes)
}

// Event validation step - ensures all registered events are emitted during testing
func (ctx *JSONSchemaBDDTestContext) allRegisteredEventsShouldBeEmittedDuringTesting() error {
	// Get all registered event types from the module
	registeredEvents := ctx.module.GetRegisteredEventTypes()

	// Create event validation observer
	validator := modular.NewEventValidationObserver("event-validator", registeredEvents)
	_ = validator // Use validator to avoid unused variable error

	// Check which events were emitted during testing
	emittedEvents := make(map[string]bool)
	for _, event := range ctx.eventObserver.GetEvents() {
		emittedEvents[event.Type()] = true
	}

	// Check for missing events
	var missingEvents []string
	for _, eventType := range registeredEvents {
		if !emittedEvents[eventType] {
			missingEvents = append(missingEvents, eventType)
		}
	}

	if len(missingEvents) > 0 {
		return fmt.Errorf("the following registered events were not emitted during testing: %v", missingEvents)
	}

	return nil
}
